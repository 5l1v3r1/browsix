#!/usr/bin/env node
// based on jvilk's XHRIndexer, but in plain JS using async APIs

'use strict';

var fs = require('fs');
var path = require('path');

var exclude = [
        /^\./, // dotfiles
        /^bower_components$/,
        /^node_modules$/,
        /^build$/,
        /^dist$/,
        /~$/, // emacs backups
];

function shouldExclude(name) {
    for (var i = 0; i < exclude.length; i++) {
        if (name.match(exclude[i]))
            return true;
    }
    return false;
}

var outstanding = 1;
var tree = {};

function subtreeAt(relative) {
    if (!relative)
	return tree;

    var parts = relative.split(path.sep);
    var subtree = tree;
    // start at 1 to skip the leading /
    for (var i = 1; i < parts.length; i++)
        subtree = subtree[parts[i]];

    return subtree;
}

function maybeFinished(file, err, onComplete) {
    if (--outstanding === 0) {
	onComplete(err, tree);
    }
}

function walkDir(base, curr, onComplete) {
    var parent = curr.slice(base.length);
    fs.readdir(curr, function(err, files) {
	if (err) {
	    maybeFinished(curr, err, onComplete);
	    return;
	}
        for (var i = 0; i < files.length; i++) {
            var file = files[i];
            if (shouldExclude(file))
                continue;

	    outstanding++;

	    var absFile = path.join(curr, file)
            fs.stat(absFile, function statFile(absFile, err, stats) {
		if (err) {
		    maybeFinished(absFile, err, onComplete);
		    return;
		}
		var parts = absFile.split(path.sep);
		var file = parts[parts.length-1];
                var subtree = subtreeAt(parent);
                if (stats.isDirectory()) {
                    subtree[file] = {};
                    walkDir(base, absFile, onComplete);
                } else {
                    subtree[file] = null;
		    maybeFinished(absFile, null, onComplete);
                }
            }.bind(null, absFile));
        }
	maybeFinished(curr, null, onComplete);
    });
}

function main() {
    const pathToNode = process.argv[0];
    const pathToScript = process.argv[1];
    const args = process.argv.slice(2);

    var root = process.cwd();
    if (args.length > 0)
        root = args[0];

    walkDir(root, root, function writeJSON(err, tree) {
        if (err) {
            process.stderr.write('error: ' + err + '\n');
            process.exit(-1);
            return;
        }
        process.stdout.write(JSON.stringify(tree) + '\n');
    });
}

main();

/*
  rdSync = (dpath, tree, name) ->
  files = fs.readdirSync(dpath)
  for file in files
  # ignore non-essential directories / files
  continue if file in ['.git', 'node_modules', 'bower_components', 'build'] or file[0] is '.'
  fpath = dpath + '/' + file
  try
  # Avoid infinite loops.
  lstat = fs.lstatSync(fpath)
  if lstat.isSymbolicLink()
  symLinks[lstat.dev] ?= {}
  # Ignore if we've seen it before
  continue if symLinks[lstat.dev][lstat.ino]?
  symLinks[lstat.dev][lstat.ino] = 0

  fstat = fs.statSync(fpath)
  if fstat.isDirectory()
  tree[file] = child = {}
  rdSync(fpath, child, file)
  else
  tree[file] = null
  catch e
  # Ignore and move on.
  return tree
*/

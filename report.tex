% BASED ON SIGPROC-SP.TEX - V3.1SP - APRIL 2009
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS

\documentclass{acm_proc_article-sp}

\usepackage{hyperref}
\hypersetup{pdfborder=0 0 0}

\begin{document}

\title{Browsix: COMPSCI 630 Project 1}
\subtitle{A UNIX-like process-model and kernel for the browser}

\numberofauthors{2}
\author{
\alignauthor Bobby Powers\\
       \email{bobbypowers@gmail.com}
\alignauthor Craig Greenberg\\
       \email{q7h0u6h7@gmail.com}
}
\date{23 Oct 2015}

\maketitle
\begin{abstract}
  This paper introduces Browsix, a UNIX-like processing model and
  kernel designed to run in modern web browsers.  The approach, system
  design, and preliminary results are described herein.
\end{abstract}

\section{Introduction}

As noted by Vilk et al., web browsers have become a \emph{de facto}
universal operating system and attractive platform for application
developers\cite{vilk:2014doppio}.  Web browsers continue to expand the
range of functionality they provide to web applications through
Javascript APIs, including primitive cooperative
multitasking\cite{mcilroy:2015chrome47} and low-level hardware
interaction like Bluetooth\cite{yasskin:2015webbluetooth}.  Javascript
and its event-based programming model have become popular outside of
web browsers - node.js (sometimes referred to as just node) being the
canonical example.  node.js enables the creation of high performance
web servers by pairing fast single-threaded execution of JavaScript
code on top of the V8 Javascript engine with asynchronous file system,
network, process management and other APIs.  Souci and
Lemaire\cite{souci:2014} describe node's architecture at a high level.

There have been multiple attempts to bring node's APIs to the Browser.
As part of Vilk et al.'s work on Doppio, an in-browser JVM, several
large node APIs were ported to the browser, most notably the fs
(filesystem) module.  The fs module is available as a Doppio
sub-project named BrowserFS.  BrowserFS provides multiple file system
backend implementations, such as an in-memory, XMLHttpRequest, dropbox
and an overlay filesystem.  This project is roughly structured similar
to the Linux VFS - all of these disparate backends are accessible
through an API identical to what node provides.  In this project we
use BrowserFS to provide a shared filesystem to all of our processes.

This project has several contributions:

\begin{itemize}
  \item An implementation of a traditional UNIX-like kernel,
    userspace, and syscall abstractions in the browser, utilizing the
    Web Workers API.  We refer to this as the process model.
  \item A port of the node.js programming environment to the browser
    on top of our process model.  We call this \texttt{browser-node}.
  \item A collection of traditional UNIX utilities, implemented as
    node.js applications in TypeScript.  These utilities run
    unmodified in both our browser environment and under node.js on
    Mac OS X and Linux.
  \item A bash-like shell that enables the composition of utilities
    into pipelines (sometimes called filters).
  \item A web-based UI for interacting with this shell that works in
    all modern browsers.
\end{itemize}


\section{Approach}

In order to enable utilities to be tested and debugged independently
of our kernel and process model implementation, all utilities were
implemented as standard node.js applications depending only on the
node.js standard library, with two small exceptions.  The shell needs
the ability to create UNIX pipes using the \texttt{pipe(2)} syscall.
node.js uses pipes internally to communicate between threads, as well
as with a certain class of child processes, but this syscall is not
exposed anywhere in the node.js API.  node.js does expose named pipes
in its net module, but we it was simpler to develop a small package to
expose an API allowing use of \texttt{pipe(2)} from JavaScript and
TypeScript.  A similar choice was made to develop a package to expose
\texttt{getpriority(2)} and \texttt{setpriority(2)}, for use in
\texttt{nice(1)}.

% diagram: utilities running on either node.js on OS X, or on
% browser-node on a browser

To run these utilities in the browser, we developed
\texttt{browser-node}.  This is a port of node.js to our in-browser
process model.  \texttt{browser-node} utilizes over a dozen of
node.js's pure-JavaScript modules directly, with almost no
modification.  Some of these modules, like \texttt{'internal/util'}
are self-contained - they don't depend on any other modules, or their
transitive-dependencies are pure-JavaScript.  However, most modules
make foreign function interface (FFI) calls into node C++ functions
and methods.  \texttt{browser-node} provides pure-JavaScript (written
in TypeScript, then compiled) implementations of these functions and
methods.  Our implementations use Web Worker APIs to post messages
representing syscalls to the kernel, invoking callbacks (back into the
node JavaScript libraries) when the kernel responds in-kind with a
syscall-response message.

A consequence of this approach is that only async APIs are
implemented.  No synchronous APIs that require invoking a system call,
such as the methods ending in \emph{Sync} in \texttt{fs}, are
available.

\section{System Design}

\section{Results}

\section{Discussion}

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{report}

\balancecolumns
\end{document}
